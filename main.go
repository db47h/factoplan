/*
Copyright 2019 Denis Bernard <db047h@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

//go:generate lua importer.lua "$HOME/.steam/steam/steamapps/common/Factorio"

package main

import (
	"flag"
	"fmt"
	"math"
	"os"
	"sort"
	"strconv"
	"strings"
	"text/tabwriter"

	"github.com/pkg/errors"
)

// Recipe wraps a factorio recipe
type Recipe struct {
	ID          string
	Time        float64
	Ingredients []Item
	Results     []Item
	Category    string
}

// A Factory wraps a factorio factory
type Factory struct {
	ID         string
	Speed      float64 // items per second
	Categories []string
}

// Item represents an ingredient or result in a crafting recipe.
//
type Item struct {
	Name   string
	Amount float64
}

// Product wraps a produced Item with its recipe. Item.Amount is the amount of this item generated by the recipe.
//
type Product struct {
	Item
	Recipe *Recipe
}

// map product names to recipes
var products map[string]*Product

// map crafting category names to factories
var categories map[string][]*Factory

func init() {
	categories = make(map[string][]*Factory)
	for i := range factories {
		f := &factories[i]
		for _, cat := range f.Categories {
			categories[cat] = append(categories[cat], f)
		}
	}
	// product map
	products = make(map[string]*Product)
	errs := false
	for i := range recipes {
		r := &recipes[i]
		for _, item := range r.Results {
			if p, ok := products[item.Name]; ok {
				fmt.Fprintf(os.Stderr, "BUG: more than one recipe for %s: Have recipes %s and %s\n", item.Name, p.Recipe.ID, r.ID)
				errs = true
			}
			products[item.Name] = &Product{Item: item, Recipe: r}
		}
	}
	if errs {
		os.Exit(1)
	}
}

type Production struct {
	p   *Product
	ipm float64
	f   *Factory
	fc  float64
}

type ProdList map[string]*Production

func (pl ProdList) add(p *Product, ipm float64) {
	if p.Recipe == nil {
		return
	}
	pn := pl[p.Name]
	if pn == nil {
		pn = &Production{p: p}
		pl[p.Name] = pn
	}
	pn.ipm += ipm

	for _, i := range p.Recipe.Ingredients {
		if ip := products[i.Name]; ip != nil {
			pl.add(ip, ipm*i.Amount/p.Amount)
		}
	}
}

func NewProduction(items []Item) (ProdList, error) {
	pl := make(ProdList)

	for _, i := range items {
		p := products[i.Name]
		if p == nil {
			return nil, errors.Errorf("unknown item %s", i.Name)
		}
		if p.Recipe == nil {
			return nil, errors.Errorf("no known recipe for item %s", i.Name)
		}

		if i.Amount == 0 {
			// calculate amount such that we can keep the fastest factory for that item 100% busy.
			if p.Recipe == nil {
				return nil, errors.Errorf("no recipe found for item %s", i.Name)
			}
			fs := categories[p.Recipe.Category]
			if fs == nil {
				return nil, errors.Errorf("no factory found for item %s", i.Name)
			}
			speed := 0.0
			for _, f := range fs {
				if f.Speed > speed {
					speed = f.Speed
				}
			}
			i.Amount = 60.0 * speed / p.Recipe.Time * p.Amount
		}
		pl.add(p, i.Amount)
	}

	// update production list with appropriate factories
	for _, p := range pl {
		r := p.p.Recipe
		fs := categories[r.Category]
		if fs == nil {
			return nil, errors.Errorf("no factory available to produce item %s", p.p.Name)
		}
		for _, f := range fs {
			// pick the slowest compatible factory as long as the number of factories does not change in order to save energy
			// divide by 60 since times are given in seconds per item
			c := p.ipm * r.Time / f.Speed / p.p.Amount / 60.0
			if p.f == nil || c < p.fc || (math.Ceil(c) == math.Ceil(p.fc) && f.Speed < p.f.Speed) {
				p.f = f
				p.fc = c
			}
		}
	}

	return pl, nil
}

func usage() {
	fmt.Fprintf(flag.CommandLine.Output(), "Usage: %s [-list] item-name[:rate] [item-name[:rate] ...]\n", os.Args[0])
	fmt.Fprintf(flag.CommandLine.Output(), `
Rates are specified in items per minute. If the rate for a given item is 0 or
omitted, it is automatically set to the fastest possible rate to keep one
factory (the fastest one for this item) 100%% busy.

Flags:
`)
	flag.PrintDefaults()
}

func main() {
	var (
		err error

		list = flag.Bool("list", false, "lists known items")
	)

	flag.CommandLine.Usage = usage
	flag.Parse()

	if *list {
		fmt.Println("Known items:")
		var el []string
		for k := range products {
			el = append(el, products[k].Name)
		}
		sort.Strings(el)
		for _, en := range el {
			fmt.Println(en)
		}
		os.Exit(0)
	}

	if flag.NArg() == 0 {
		usage()
		os.Exit(0)
	}

	items := make([]Item, flag.NArg())
	for i, a := range flag.Args() {
		item := &items[i]
		col := strings.IndexByte(a, ':')
		if col >= 0 {
			item.Name = a[:col]
			item.Amount, err = strconv.ParseFloat(a[col+1:], 64)
			if err != nil {
				fmt.Fprintf(os.Stderr, errors.Wrapf(err, "failed to parse rate for item %s", item.Name).Error())
				os.Exit(0)
			}
		} else {
			item.Name = a
			item.Amount = 0
		}
	}

	pl, err := NewProduction(items)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}

	var spl []*Production
	for _, p := range pl {
		spl = append(spl, p)
	}
	sort.Slice(spl, func(i, j int) bool {
		return spl[i].f.ID < spl[j].f.ID || (spl[i].f.ID == spl[j].f.ID && spl[i].p.Name < spl[j].p.Name)
	})

	w := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
	fmt.Fprintf(w, "#\tFactory\tItem\titems/m\titems/s\n")
	fmt.Fprintf(w, "--\t---------------------\t-----------------------\t-------\t-------\n")

	for _, p := range spl {
		fmt.Fprintf(w, "%.0f\t%s\t%s\t%.1f\t%.2f\n", math.Ceil(p.fc), p.f.ID, p.p.Name, p.ipm, p.ipm/60.0)
	}
	w.Flush()
}
