/*
Copyright 2019 Denis Bernard <db047h@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

//go:generate lua importer.lua "$HOME/.steam/steam/steamapps/common/Factorio"

package main

import (
	"flag"
	"fmt"
	"math"
	"os"
	"sort"
	"strings"
	"text/tabwriter"

	"github.com/pkg/errors"
)

// Recipe wraps a factorio recipe
type Recipe struct {
	ID          string
	Time        float64
	Ingredients []Item
	Results     []Item
	Category    string
}

// A Factory wraps a factorio factory
type Factory struct {
	ID         string
	Speed      float64 // items per second
	Categories []string
}

// Item represents an ingredient or result in a crafting recipe.
//
type Item struct {
	Name   string
	Amount float64
}

// Product wraps a produced Item with its recipe. Item.Amount is the amount of this item generated by the recipe.
//
type Product struct {
	Item
	Recipe *Recipe
}

// map product names to recipes
var products map[string]*Product

// map crafting category names to factories
var categories map[string][]*Factory

func init() {
	categories = make(map[string][]*Factory)
	for i := range factories {
		f := &factories[i]
		for _, cat := range f.Categories {
			categories[cat] = append(categories[cat], f)
		}
	}
	// product map
	products = make(map[string]*Product)
	errs := false
	for i := range recipes {
		r := &recipes[i]
		for _, item := range r.Results {
			if p, ok := products[item.Name]; ok {
				fmt.Fprintf(os.Stderr, "BUG: more than one recipe for %s: Have recipes %s and %s\n", item.Name, p.Recipe.ID, r.ID)
				errs = true
			}
			products[item.Name] = &Product{Item: item, Recipe: r}
		}
	}
	if errs {
		os.Exit(1)
	}
}

type Production struct {
	p   *Product
	ips float64
	f   *Factory
	fc  float64
}

type ProdList map[string]*Production

func (pl ProdList) add(p *Product, ips float64) {
	if p.Recipe == nil {
		return
	}
	pn := pl[p.Name]
	if pn == nil {
		pn = &Production{p: p}
		pl[p.Name] = pn
	}
	pn.ips += ips

	for _, i := range p.Recipe.Ingredients {
		if ip := products[i.Name]; ip != nil {
			pl.add(ip, ips*i.Amount/p.Amount)
		}
	}
}

func NewProduction(name string, ips float64) (ProdList, error) {
	pl := make(ProdList)

	p := products[name]
	if p == nil {
		return nil, errors.Errorf("unknown item %s", name)
	}
	if p.Recipe == nil {
		return nil, errors.Errorf("no known recipe for item %s", name)
	}

	pl.add(p, ips)

	// update production list with appropriate factories
	for _, p := range pl {
		r := p.p.Recipe
		fs := categories[r.Category]
		if fs == nil {
			return nil, errors.Errorf("no factory available to produce item %s", p.p.Name)
		}
		for _, f := range fs {
			// pick the slowest compatible factory as long as the number of factories does not change in order to save energy
			c := math.Ceil(p.ips * r.Time / f.Speed / p.p.Amount)
			if p.f == nil || c < p.fc || (c == p.fc && f.Speed < p.f.Speed) {
				p.f = f
				p.fc = c
			}
		}
	}

	return pl, nil
}

func main() {
	var (
		err error

		list = flag.Bool("list", false, "lists known items")
		name = flag.String("i", "", "item `name`")
		ips  = flag.Float64("r", 1.0, "production rate in `items per second`")
	)

	flag.Parse()

	if *list {
		fmt.Println("Known items:")
		var el []string
		for k := range products {
			el = append(el, products[k].Name)
		}
		sort.Strings(el)
		for _, en := range el {
			fmt.Println(en)
		}
		os.Exit(0)
	}

	if *ips <= 0.0 {
		fmt.Fprintf(os.Stderr, "error: items per second must be a non-zero positive number")
	}

	*name = strings.Replace(strings.ToLower(*name), " ", "_", -1)

	pl, err := NewProduction(*name, *ips)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}

	var spl []*Production
	for _, p := range pl {
		spl = append(spl, p)
	}
	sort.Slice(spl, func(i, j int) bool {
		return spl[i].f.ID < spl[j].f.ID || (spl[i].f.ID == spl[j].f.ID && spl[i].p.Name < spl[j].p.Name)
	})

	w := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
	fmt.Fprintf(w, "#\tFactory\tItem\titems/s\titems/m\n")
	fmt.Fprintf(w, "--\t---------------------\t-----------------------\t-------\t-------\n")

	for _, p := range spl {
		fmt.Fprintf(w, "%.0f\t%s\t%s\t%.2f\t%.0f\n", p.fc, p.f.ID, p.p.Name, p.ips, p.ips*60.0)
	}
	w.Flush()
}
