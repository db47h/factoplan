//go:generate lua importer.lua "$HOME/.steam/steam/steamapps/common/Factorio"

package main

import (
	"flag"
	"fmt"
	"math"
	"os"
	"sort"
	"strings"
	"text/tabwriter"

	"github.com/pkg/errors"
)

// Recipe wraps a factorio recipe
type Recipe struct {
	ID          string
	Time        float64
	Ingredients []Item
	Results     []Item
	Category    string
}

// A Factory wraps a factorio factory
type Factory struct {
	ID         string
	Speed      float64 // items per second
	Categories []string
}

// Item represents an ingredient or result in a crafting recipe.
//
type Item struct {
	Name   string
	Amount float64
}

// Product wraps a produced Item with its recipe. Item.Amount is the amount of this item generated by the recipe.
//
type Product struct {
	Item
	Recipe *Recipe
}

// map product names to recipes
var products map[string]*Product

// map crafting category names to factories
var categories map[string][]*Factory

func init() {
	categories = make(map[string][]*Factory)
	for i := range factories {
		f := &factories[i]
		for _, cat := range f.Categories {
			categories[cat] = append(categories[cat], f)
		}
	}
	// product map
	products = make(map[string]*Product)
	errs := false
	for i := range recipes {
		r := &recipes[i]
		for _, item := range r.Results {
			if p, ok := products[item.Name]; ok {
				fmt.Fprintf(os.Stderr, "BUG: more than one recipe for %s: Have recipes %s and %s\n", item.Name, p.Recipe.ID, r.ID)
				errs = true
			}
			products[item.Name] = &Product{Item: item, Recipe: r}
		}
	}
	if errs {
		os.Exit(1)
	}
}

type Production struct {
	p   *Product
	ips float64
	f   *Factory
	fc  float64
}

type ProdList map[string]*Production

func (pl ProdList) add(p *Product, ips float64) {
	if p.Recipe == nil {
		return
	}
	pn := pl[p.Name]
	if pn == nil {
		pn = &Production{p: p}
		pl[p.Name] = pn
	}
	pn.ips += ips

	for _, i := range p.Recipe.Ingredients {
		if ip := products[i.Name]; ip != nil {
			pl.add(ip, ips*i.Amount/p.Amount)
		}
	}
}

func NewProduction(name string, ips float64) (ProdList, error) {
	pl := make(ProdList)

	p := products[name]
	if p == nil {
		return nil, errors.Errorf("unknown item %s", name)
	}
	if p.Recipe == nil {
		return nil, errors.Errorf("no known recipe for item %s", name)
	}

	pl.add(p, ips)

	// update production list with appropriate factories
	for _, p := range pl {
		r := p.p.Recipe
		fs := categories[r.Category]
		if fs == nil {
			return nil, errors.Errorf("no factory available to produce item %s", p.p.Name)
		}
		for _, f := range fs {
			// pick the slowest compatible factory as long as the number of factories does not change in order to save energy
			c := math.Ceil(p.ips * r.Time / f.Speed / p.p.Amount)
			if p.f == nil || c < p.fc || (c == p.fc && f.Speed < p.f.Speed) {
				p.f = f
				p.fc = c
			}
		}
	}

	return pl, nil
}

func main() {
	var (
		err error

		list = flag.Bool("list", false, "lists known items")
		name = flag.String("i", "", "item `name`")
		ips  = flag.Float64("r", 1.0, "production rate in `items per second`")
	)

	flag.Parse()

	if *list {
		fmt.Println("Known items:")
		var el []string
		for k := range products {
			el = append(el, products[k].Name)
		}
		sort.Strings(el)
		for _, en := range el {
			fmt.Println(en)
		}
		os.Exit(0)
	}

	if *ips <= 0.0 {
		fmt.Fprintf(os.Stderr, "error: items per second must be a non-zero positive number")
	}

	*name = strings.Replace(strings.ToLower(*name), " ", "_", -1)

	pl, err := NewProduction(*name, *ips)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}

	var spl []*Production
	for _, p := range pl {
		spl = append(spl, p)
	}
	sort.Slice(spl, func(i, j int) bool {
		return spl[i].f.ID < spl[j].f.ID || (spl[i].f.ID == spl[j].f.ID && spl[i].p.Name < spl[j].p.Name)
	})

	w := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', 0)
	fmt.Fprintf(w, "#\tFactory\tItem\titems/s\titems/m\n")
	fmt.Fprintf(w, "--\t---------------------\t-----------------------\t-------\t-------\n")

	for _, p := range spl {
		fmt.Fprintf(w, "%.0f\t%s\t%s\t%.2f\t%.0f\n", p.fc, p.f.ID, p.p.Name, p.ips, p.ips*60.0)
	}
	w.Flush()
}
